# -*- coding: utf-8 -*-
"""OpenCV

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WGG_BKcNsKVqWL4vaU2Ft9cnu4T1pn5I
"""

!pip install opencv-python
!pip install numpy
!pip install matplotlib

"""# *Testar instalação dos pacotes*"""

#imports

import cv2

"""**TODO: escrita do code**

*Functions*
"""

# funcoes

def showImage(obj_img):
  # converter de BGR to RGB
  # por padrao as imagens sao abertas no formato BGR
  obj_img = cv2.cvtColor(obj_img,cv2.COLOR_BGR2RGB)

  plt.imshow(obj_img)
  #plt.show()
  plt
def printImage(obj_img):
  """alias"""
  showImage(obj_img)
def getColor(obj_img,y,x):
  # acessar pixeis da forma recomendada
  return obj_img.item(y,x,0),obj_img.item(y,x,1),obj_img.item(y,x,2)
def setColor(obj_img,y,x,b,g,r):
  # alterar pixeis
  obj_img.itemset((y,x,0),b)#azul
  obj_img.itemset((y,x,1),g)#verde
  obj_img.itemset((y,x,2),r)#vermelho

"""*Flags*"""

# carregar imagem em tons de preto
cor = 'preto-' # preto or other

import numpy as np
import cv2
from matplotlib import pyplot as plt

# not sucess but run return none
#obj_img = cv2.imread('https://cdn.pixabay.com/photo/2012/04/24/11/24/one-39418_960_720.png')

if cor != 'preto':
  # retorna os pixeis na ordem BGR
  img = cv2.imread('drive/My Drive/opencv/image1_numero_em_um_fundo_redondo_com_cor.jpeg')
  altura, largura, canais_de_cor = img.shape
elif cor == 'preto':
  # carrega a imagem em preto em branco
  img = cv2.imread('drive/My Drive/opencv/image1_numero_em_um_fundo_redondo_com_cor.jpeg',0)
  altura, largura = img.shape
else:
  raise Exception('ERROR_MASTER')
print(img.shape)
showImage(img)

# Ver formato da matriz de pixeis

print(img)

# Deixar a imagem em tons de azul

for y in range(0,altura):
  for x in range(0,largura):
    azul,verde,vermelho = getColor(img,y,x)
    b = azul
    setColor(img,y,x,b,0,0)
showImage(img)

"""*Salvando imagem*"""

cv2.imwrite('blue.png',img)

"""*Cortar imagens*"""

# [y,x]
cut_img = img[100:200,100:400]
showImage(cut_img)

"""*Inserir imagem em outra imagem*"""

# erro ao tentar gerar uma imagem maior
#obj_img[300:300+cut_img.shape[0],300:300+cut_img.shape[1]] = cut_img

# imagem a ser inserida
# as coordenadas precisam estar contida dentro da imagem
# shape retorna width , height , canais de cor
img[300:300+cut_img.shape[0],50:50+cut_img.shape[1]] = cut_img
showImage(img)

# splitting and merging image channels

b,g,r = cv2.split(img)
img = cv2.merge((b,g,r))

b = img[:,:,0]
g = img[:,:,1]
r = img[:,:,2]

# alterar channel green para 129
img[:,:,1] = 129
showImage(img)

# testar multi plot
# veja o notebook OpenCV_04_padding...

fig, axis = plt.subplots(1,2,figsize = (10, 10))

imgMPLIB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
fig.suptitle('titlesArray asdasd qwewqe fvsdfsdf xcvxcvx')
axis[0].imshow(imgMPLIB)
#axis[1].imshow(imgMPLIB)
#axis.set_title('title', fontdict = {'fontsize': 22, 'fontweight': 'medium'})
plt.show()

# criar imagem transparente
imgTransparent = np.ones((img.shape[0], img.shape[1], 4), np.uint8) * 255
imgTransparent = np.ones((400, 100, 4), np.uint8) * 255
width = 100
heigth = 400
imgTransparent = np.ones((heigth, width, 4), np.uint8) * 255
x = 100
y = 400
imgTransparent = np.ones((y, x, 4), np.uint8) * 255
showImage(imgTransparent)